#!/usr/bin/env python
import argparse
import os
import re
import subprocess
import sys
from pathlib import Path

import requests

PROJECT_ROOT_PATH = Path(__file__).parent.parent
VERSION_FILE_PATH = PROJECT_ROOT_PATH / 'aito' / '__init__.py'
CHANGE_LOG_FILE_PATH = PROJECT_ROOT_PATH / 'docs' / 'source' / 'changelog.rst'


def check_at_top():
    cwd = Path(os.getcwd())
    if not (cwd / 'aito' / '__init__.py').exists():
        raise RuntimeError("this script must be run from the project directory")


def find_current_version(version_file_path: Path) -> str:
    with version_file_path.open() as f:
        init_content = f.read()

    version_match = re.search(r"^__version__ = ['\"]([^'\"]*)['\"]", init_content, re.M)
    if version_match:
        return version_match.group(1)
    raise RuntimeError("Unable to find version string.")


def update_version_file(version_file_path: Path, new_version: str):
    with version_file_path.open() as f:
        init_content = f.read()
    with version_file_path.open('w') as f:
        f.write(re.sub(r"^__version__ = ['\"]([^'\"]*)['\"]", f'__version__ = "{new_version}"', init_content, re.M))

    assert find_current_version(version_file_path) == new_version, 'version is not updated'


def get_all_versions(repo):
    url = f'https://{repo}.org/pypi/aitoai/json'
    package_info = requests.get(url).json()
    return package_info['releases'].keys()


def bump_version(version: str, mechanism: str) -> str:
    mechanism_part_idx = {
        'major': 0,
        'minor': 1,
        'micro': 2,
        'dev': 3,
        'rc': 3,
        'post': 3
    }
    parts = version.split('.')
    if mechanism in mechanism_part_idx:
        idx = mechanism_part_idx[mechanism]
        if idx != 3:
            new_parts = parts[:idx] + [str(int(parts[idx]) + 1)] + ['0'] * (2 - idx)
        else:
            if len(parts) < 4:
                new_parts = parts + [f'{mechanism}1']
            else:
                if parts[3].startswith(mechanism):
                    prev_v = parts[3].split(mechanism)[1]
                    new_parts = parts[:3] + [f'{mechanism}{int(prev_v) + 1}']
                else:
                    new_parts = parts[:3] + [f'{mechanism}1']
        return '.'.join(new_parts)
    else:
        raise RuntimeError(f'unexpected level {mechanism}')


def build_package_and_check():
    print('cleaning dist dir')
    dist_path = PROJECT_ROOT_PATH / 'dist'
    if dist_path.exists():
        for file in dist_path.glob('*'):
            file.unlink()
    subprocess.run(['python', 'setup.py', 'sdist', 'bdist_wheel'], check=True)
    subprocess.run(['twine', 'check', 'dist/*'], check=True)


def publish(repo):
    if repo == 'test.pypi':
        subprocess.run(['twine', 'upload', '--repository-url', 'https://test.pypi.org/legacy/', 'dist/*'], check=True)
    elif repo == 'pypi':
        subprocess.run(['twine', 'upload', 'dist/*'], check=True)


def check_version_change_log(change_log_file_path: Path, new_version: str):
    with change_log_file_path.open() as in_f:
        change_log_content = in_f.read()
    if not re.search(f'^{new_version}', change_log_content, re.M):
        raise RuntimeError(f'version {new_version} changelog not found')


def git_bump_version_and_tag(new_version):
    subprocess.run(['git', 'commit', '--allow-empty', '-m', f'Bump to {new_version}'], check=True)
    subprocess.run(['git', 'tag', new_version], check=True)
    subprocess.run(['git', 'push'], check=True)
    subprocess.run(['git', 'push', '--tags'], check=True)


def check_git_tree():
    process = subprocess.run(['git', 'status', '--porcelain'], check=True, stdout=subprocess.PIPE)
    if process.stdout:
        raise RuntimeError('tree is dirty, please commit changes before deployment')


class DeployParser(argparse.ArgumentParser):
    def error(self, message):
        sys.stderr.write(f"error: {message}\n")
        self.print_help()
        sys.exit(2)

    def __init__(self):
        super().__init__()

        self.add_argument('repo', type=str, choices=['test.pypi', 'pypi'], help='repo to be published to')
        group = self.add_mutually_exclusive_group()

        group.add_argument('-v', '--version', type=str, help='deploy a specific version')
        group.add_argument(
            '-b', '--bump-mechanism', type=str, choices=['dev', 'rc', 'post', 'micro', 'minor', 'major'],
            help='specify the mechanism to bump the current version'
        )
        self.add_argument(
            '-s', '--step', type=int, default=1,
            help='the number of steps to be bumped if use bump version (default to 1: rc1 => rc2)'
        )
        self.add_argument(
            '-n', '--no-publish', action='store_true', help='not publish to repo'
        )

    def __call__(self):
        check_at_top()
        check_git_tree()

        parsed_args = vars(self.parse_args())
        repo = parsed_args['repo']

        all_versions = get_all_versions(repo)
        # FIXME: comparison between 2 versions
        latest_version = sorted(all_versions, reverse=True)[0]
        deploy_version = find_current_version(VERSION_FILE_PATH)
        if parsed_args['version']:
            deploy_version = parsed_args['version']
        elif parsed_args['bump_version']:
            mechanism = parsed_args['bump_version']
            deploy_version = bump_version(deploy_version, mechanism)
        if deploy_version in all_versions:
            self.error(f'deploy version {deploy_version} already exist')
        # FIXME:
        if deploy_version <= latest_version:
            self.error(f'deploy version {deploy_version} < latest version {latest_version}')

        update_version_file(VERSION_FILE_PATH, deploy_version)
        build_package_and_check()

        if not parsed_args['no_publish']:
            if repo == 'pypi':
                check_version_change_log(CHANGE_LOG_FILE_PATH, deploy_version)
                git_bump_version_and_tag(deploy_version)
                subprocess.run(['./scripts/build_docs.sh'], check=True)
                publish(repo)
                subprocess.run(['./scripts/publish_docs.sh', deploy_version], check=True)
            else:
                publish(repo)


DeployParser()()
