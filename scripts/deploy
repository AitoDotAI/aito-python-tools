#!/usr/bin/env python
import argparse
import os
import re
import subprocess
import sys
from pathlib import Path
from typing import List
from datetime import datetime

import requests
from packaging.version import Version

PROJECT_ROOT_PATH = Path(__file__).parent.parent
VERSION_FILE_PATH = PROJECT_ROOT_PATH / 'aito' / '__init__.py'
CHANGE_LOG_FILE_PATH = PROJECT_ROOT_PATH / 'docs' / 'source' / 'changelog.rst'
DEFAULT_SPECIAL_RELEASE_LETTER = {
    'pre': 'rc',
    'dev': 'dev',
    'post': 'post'
}


def check_at_top():
    cwd = Path(os.getcwd())
    if not (cwd / 'aito' / '__init__.py').exists():
        raise RuntimeError("this script must be run from the project directory")


def find_current_version(version_file_path: Path) -> Version:
    with version_file_path.open() as f:
        init_content = f.read()

    version_match = re.search(r"^__version__ = ['\"]([^'\"]*)['\"]", init_content, re.M)
    if version_match:
        version_str = version_match.group(1)
    else:
        raise ValueError(f'Unable to find version string in {version_file_path}')
    return Version(version_str)


def update_version_file(version_file_path: Path, new_version: Version):
    with version_file_path.open() as f:
        init_content = f.read()
    with version_file_path.open('w') as f:
        f.write(re.sub(r"^__version__ = ['\"]([^'\"]*)['\"]", f'__version__ = "{new_version}"', init_content, re.M))

    assert find_current_version(version_file_path) == new_version, 'version is not updated'


def get_all_existing_versions(repo) -> List[Version]:
    url = f'https://{repo}.org/pypi/aitoai/json'
    package_info = requests.get(url).json()
    return [Version(v) for v in package_info['releases'].keys()]


def bump_version(current_version: Version, bump_part: str) -> Version:
    final_releases_parts = ['major', 'minor', 'micro']
    parts = [
        str(getattr(current_version, part) + 1) if part == bump_part else str(getattr(current_version, part))
        for part in final_releases_parts
    ]
    if bump_part in DEFAULT_SPECIAL_RELEASE_LETTER:
        now = datetime.now()
        dt_string = now.strftime("%Y%m%d%H%M%S")
        parts.append(f'{DEFAULT_SPECIAL_RELEASE_LETTER[bump_part]}{dt_string}')
    return Version('.'.join(parts))


def validate_new_version(new_version: Version, all_existing_versions: List[Version]):
    if new_version in all_existing_versions:
        raise ValueError(f'new version {new_version} already exists')
    latest_version = sorted(all_existing_versions, reverse=True)[0]
    if new_version < latest_version and not new_version.is_postrelease:
        raise ValueError(f'new version {new_version} is not a post release and < latest version {latest_version}')
    if new_version.is_prerelease or new_version.is_devrelease:
        new_v_base = new_version.base_version
        if Version(new_v_base) in all_existing_versions:
            raise ValueError(f'new version {new_version} is a pre or dev release of a released version({new_v_base})')
    if new_version.is_postrelease:
        new_v_base = new_version.base_version
        if Version(new_v_base) not in all_existing_versions:
            raise ValueError(f'new version {new_version} is a post release of a non-existing version({new_v_base})')
    return True


def build_package_and_check():
    print('cleaning dist dir')
    dist_path = PROJECT_ROOT_PATH / 'dist'
    if dist_path.exists():
        for file in dist_path.glob('*'):
            file.unlink()
    subprocess.run(['python', 'setup.py', 'sdist', 'bdist_wheel'], check=True)
    subprocess.run(['twine', 'check', 'dist/*'], check=True)


def publish(repo: str):
    if repo == 'test.pypi':
        subprocess.run(['twine', 'upload', '--repository-url', 'https://test.pypi.org/legacy/', 'dist/*'], check=True)
    elif repo == 'pypi':
        subprocess.run(['twine', 'upload', 'dist/*'], check=True)


def check_version_change_log_exist(change_log_file_path: Path, new_version: Version):
    if not change_log_file_path.exists():
        raise ValueError(f'Change log file {change_log_file_path} does not exist')
    with change_log_file_path.open() as in_f:
        change_log_content = in_f.read()
    if not re.search(f'^{new_version}', change_log_content, re.M):
        raise ValueError(f'version {new_version} changelog not found')


def git_bump_version_and_tag(new_version):
    subprocess.run(['git', 'commit', '--allow-empty', '-m', f'Bump to {new_version}'], check=True)
    subprocess.run(['git', 'tag', new_version], check=True)
    subprocess.run(['git', 'push'], check=True)
    subprocess.run(['git', 'push', '--tags'], check=True)


def check_git_tree():
    process = subprocess.run(['git', 'status', '--porcelain'], check=True, stdout=subprocess.PIPE)
    if process.stdout:
        raise RuntimeError('tree is dirty, please commit changes before deployment')


class DeployParser(argparse.ArgumentParser):
    def error(self, message):
        sys.stderr.write(f"error: {message}\n")
        self.print_help()
        sys.exit(2)

    def __init__(self):
        super().__init__()

        self.add_argument('repo', type=str, choices=['test.pypi', 'pypi'], help='repo to be published to')
        m_e_group = self.add_mutually_exclusive_group()

        m_e_group.add_argument('-v', '--version', type=str, help='deploy with the specified version')

        m_e_group.add_argument(
            '-b', '--bump-version', type=str, choices=['dev', 'pre', 'post', 'micro', 'minor', 'major'],
            help='bump the current version with the specified part'
        )
        self.add_argument(
            '-n', '--no-publish', action='store_true', help='Do not publish to repo'
        )

    def __call__(self):
        check_at_top()
        check_git_tree()

        parsed_args = vars(self.parse_args())

        current_version = find_current_version(VERSION_FILE_PATH)
        if parsed_args['version']:
            new_version = Version(parsed_args['version'])
        elif parsed_args['bump_version']:
            bump_part = parsed_args['bump_version']
            new_version = bump_version(current_version, bump_part)
        else:
            new_version = current_version

        repo = parsed_args['repo']
        all_existing_versions = get_all_existing_versions(repo)
        validate_new_version(new_version, all_existing_versions)
        update_version_file(VERSION_FILE_PATH, new_version)
        build_package_and_check()

        if not parsed_args['no_publish']:
            if repo == 'pypi':
                check_version_change_log_exist(CHANGE_LOG_FILE_PATH, new_version)
                subprocess.run(['./scripts/build_docs.sh'], check=True)
                publish(repo)
                subprocess.run(['./scripts/publish_docs.sh', new_version], check=True)
                git_bump_version_and_tag(new_version)
            else:
                publish(repo)


DeployParser()()
