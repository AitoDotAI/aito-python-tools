#!/usr/bin/env python
import argparse
import re
import subprocess
import sys
from pathlib import Path
from typing import Optional

import requests

PROJECT_ROOT_PATH = Path(__file__).parent.parent
VERSION_FILE_PATH = PROJECT_ROOT_PATH / 'aito' / '__init__.py'
CHANGE_LOG_FILE_PATH = PROJECT_ROOT_PATH / 'docs' / 'source' / 'changelog.rst'


def find_current_version(version_file_path: Path) -> str:
    with version_file_path.open() as f:
        init_content = f.read()

    version_match = re.search(r"^__version__ = ['\"]([^'\"]*)['\"]", init_content, re.M)
    if version_match:
        return version_match.group(1)
    raise RuntimeError("Unable to find version string.")


def update_version(version_file_path: Path, new_version: str):
    with version_file_path.open() as f:
        init_content = f.read()
    with version_file_path.open('w') as f:
        f.write(re.sub(r"^__version__ = ['\"]([^'\"]*)['\"]", f'__version__ = "{new_version}"', init_content, re.M))

    assert find_current_version(version_file_path) == new_version, 'version is not updated'


def get_latest_version(repo):
    url = f'https://{repo}.org/pypi/aitoai/json'
    package_info = requests.get(url).json()
    return sorted(package_info['releases'].keys(), reverse=True)[0]


def generate_new_version(latest_version: str, repo: str, level: Optional[str]) -> str:
    levels_idx = {
        'major': 0,
        'minor': 1,
        'micro': 2
    }
    latest_parts = latest_version.split('.')
    if level in levels_idx:
        idx = levels_idx[level]
        new_parts = latest_parts[:idx] + [str(int(latest_parts[idx]) + 1)] + ['0'] * (2 - idx)
        if repo == 'test.pypi':
            new_parts.append('dev1')
        return '.'.join(new_parts)
    elif level == 'dev':
        if len(latest_parts) < 4:
            new_parts = latest_parts + ['dev1']
        else:
            if latest_parts[3].startswith('dev'):
                new_parts = latest_parts[:3] + [f'dev{int(latest_parts[3].split("dev")[1]) + 1}']
            else:
                new_parts = latest_parts[:3] + ['dev1']
        return '.'.join(new_parts)
    else:
        RuntimeError(f'unexpected level {level}')


def build_package_and_check():
    print('cleaning dist dir')
    dist_path = PROJECT_ROOT_PATH / 'dist'
    if dist_path.exists():
        for file in dist_path.glob('*'):
            file.unlink()
    subprocess.run(['python', 'setup.py', 'sdist', 'bdist_wheel'], check=True)
    subprocess.run(['twine', 'check', 'dist/*'], check=True)


def publish(repo):
    if repo == 'test.pypi':
        subprocess.run(['twine', 'upload', '--repository-url', 'https://test.pypi.org/legacy/', 'dist/*'], check=True)
    elif repo == 'pypi':
        subprocess.run(['twine', 'upload', 'dist/*'], check=True)


def check_version_change_log(change_log_file_path: Path, new_version: str):
    with change_log_file_path.open() as in_f:
        change_log_content = in_f.read()
    if not re.search(f'^{new_version}', change_log_content, re.M):
        return False
    return True


def git_bump_version_and_tag(new_version):
    subprocess.run(['git', 'commit', '-am', f'Bump to {new_version}'], check=True)
    subprocess.run(['git', 'tag', '$NEW_VERSION'], check=True)
    subprocess.run(['git', 'push'], check=True)
    subprocess.run(['git', 'push', '--tags'], check=True)


def check_git_tree():
    process = subprocess.run(['git', 'status', '--porcelain'], check=True, stdout=subprocess.PIPE)
    if process.stdout:
        sys.exit('tree is dirty, please commit changes before deployment')


class DeployParser(argparse.ArgumentParser):
    def error(self, message):
        sys.stderr.write(f"error: {message}\n")
        self.print_help()
        sys.exit(2)

    def __init__(self):
        super().__init__()

        self.add_argument('repo', type=str, choices=['test.pypi', 'pypi'], help='repo to be published to')
        group = self.add_mutually_exclusive_group()
        group.required = True

        group.add_argument('-v', '--version', type=str, help='deploy a specific version')
        group.add_argument(
            '-l', '--level', type=str, choices=['keep', 'dev', 'micro', 'minor', 'major'],
            help='specify the level to be bumped from current version (default to keep the current version)'
        )
        self.add_argument(
            '-n', '--no-publish', action='store_true', help='not publish to repo'
        )

    def __call__(self):
        if not (PROJECT_ROOT_PATH / 'aito' / '__init__.py').exists():
            sys.exit('this script must be run from the project root')

        parsed_args = vars(self.parse_args())

        check_git_tree()
        repo = parsed_args['repo']

        latest_version = get_latest_version(repo)
        if parsed_args['version']:
            new_version = parsed_args['version']
        else:
            level = parsed_args['level']
            if level == 'dev' and repo == 'pypi':
                self.error('cannot use dev level for pypi')
            if level == 'keep':
                new_version = find_current_version(VERSION_FILE_PATH)
            else:
                new_version = generate_new_version(latest_version, repo, level)

        if new_version <= latest_version:
            sys.exit(f'deploy version {new_version} < latest version {latest_version}')

        update_version(VERSION_FILE_PATH, new_version)
        build_package_and_check()

        if not parsed_args['no_publish']:
            if repo == 'pypi':
                check_version_change_log(CHANGE_LOG_FILE_PATH, new_version)
                git_bump_version_and_tag(new_version)
                subprocess.run(['./scripts/deploy_docs.sh', new_version], check=True)
            publish(repo)


DeployParser()()
